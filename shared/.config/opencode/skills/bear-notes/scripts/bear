#!/usr/bin/env bash

set -euo pipefail

# Bear database path
DB="$HOME/Library/Group Containers/9K33E3U3T4.net.shinyfrog.bear/Application Data/database.sqlite"

# Bear uses Core Data timestamps (seconds since 2001-01-01)
CORE_DATA_EPOCH="2001-01-01 00:00:00"

# URL encode function for x-callback-url parameters
urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}

# Convert Core Data timestamp to human-readable date
format_timestamp() {
    local ts="$1"
    if [[ -z "$ts" || "$ts" == "null" ]]; then
        echo "null"
        return
    fi
    # Add Core Data epoch offset to get Unix timestamp
    local unix_ts=$(echo "978307200 + $ts" | bc)
    date -r "${unix_ts%.*}" "+%Y-%m-%dT%H:%M:%S" 2>/dev/null || echo "null"
}

# Format note as JSON (for single note display)
format_note_json() {
    local id="$1" title="$2" text="$3" created="$4" modified="$5"
    local include_content="${6:-false}"

    created=$(format_timestamp "$created")
    modified=$(format_timestamp "$modified")

    if [[ "$include_content" == "true" ]]; then
        jq -n \
            --arg id "$id" \
            --arg title "${title:-Untitled}" \
            --arg content "$text" \
            --arg created "$created" \
            --arg modified "$modified" \
            '{id: $id, title: $title, content: $content, created: $created, modified: $modified}'
    else
        local preview="${text:0:200}"
        [[ ${#text} -gt 200 ]] && preview="${preview}..."
        jq -n \
            --arg id "$id" \
            --arg title "${title:-Untitled}" \
            --arg preview "$preview" \
            --arg created "$created" \
            --arg modified "$modified" \
            '{id: $id, title: $title, content_preview: $preview, created: $created, modified: $modified}'
    fi
}

# Execute Bear x-callback-url
execute_bear_url() {
    local url="$1"
    open "$url" 2>/dev/null || echo '{"error": "Failed to execute Bear command"}'
}

# Build Bear x-callback-url
build_url() {
    local action="$1"
    shift
    local params=""

    while [[ $# -gt 0 ]]; do
        local key="$1"
        local value="$2"
        shift 2

        if [[ -n "$params" ]]; then
            params="${params}&"
        fi
        params="${params}${key}=$(urlencode "$value")"
    done

    echo "bear://x-callback-url/${action}?${params}"
}

# Check if database exists
check_db() {
    if [[ ! -f "$DB" ]]; then
        echo '{"error": "Bear database not found. Is Bear installed?"}' >&2
        exit 1
    fi
}

# Command implementations

cmd_search() {
    local term="$1"
    local tag="${2:-}"

    check_db

    if [[ -n "$tag" ]]; then
        sqlite3 -json "$DB" "
            SELECT DISTINCT n.ZUNIQUEIDENTIFIER, n.ZTITLE, n.ZTEXT, n.ZCREATIONDATE, n.ZMODIFICATIONDATE
            FROM ZSFNOTE n
            JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES
            JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK
            WHERE (n.ZTITLE LIKE '%${term}%' OR n.ZTEXT LIKE '%${term}%')
              AND t.ZTITLE LIKE '%${tag}%'
              AND n.ZTRASHED = 0
            ORDER BY n.ZMODIFICATIONDATE DESC
            LIMIT 20
        " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
    else
        sqlite3 -json "$DB" "
            SELECT ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT, ZCREATIONDATE, ZMODIFICATIONDATE
            FROM ZSFNOTE
            WHERE (ZTITLE LIKE '%${term}%' OR ZTEXT LIKE '%${term}%')
              AND ZTRASHED = 0
            ORDER BY ZMODIFICATIONDATE DESC
            LIMIT 20
        " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
    fi
}

cmd_open() {
    local id="$1"

    check_db

    local note
    note=$(sqlite3 -json "$DB" "
        SELECT ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT, ZCREATIONDATE, ZMODIFICATIONDATE
        FROM ZSFNOTE
        WHERE ZUNIQUEIDENTIFIER = '${id}' AND ZTRASHED = 0
    ")

    if [[ $(echo "$note" | jq '. | length') -eq 0 ]]; then
        echo '{"error": "Note not found"}'
        exit 1
    fi

    local tags
    tags=$(sqlite3 -json "$DB" "
        SELECT t.ZTITLE
        FROM ZSFNOTETAG t
        JOIN Z_5TAGS nt ON t.Z_PK = nt.Z_13TAGS
        JOIN ZSFNOTE n ON nt.Z_5NOTES = n.Z_PK
        WHERE n.ZUNIQUEIDENTIFIER = '${id}'
    " | jq -c '[.[].ZTITLE]')

    echo "$note" | jq -c --argjson tags "$tags" '.[0] | {
        id: .ZUNIQUEIDENTIFIER,
        title: (.ZTITLE // "Untitled"),
        content: .ZTEXT,
        created: .ZCREATIONDATE,
        modified: .ZMODIFICATIONDATE,
        tags: $tags
    }'
}

cmd_open_title() {
    local title="$1"

    check_db

    local note
    note=$(sqlite3 -json "$DB" "
        SELECT ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT, ZCREATIONDATE, ZMODIFICATIONDATE
        FROM ZSFNOTE
        WHERE ZTITLE = '${title}' AND ZTRASHED = 0
    ")

    if [[ $(echo "$note" | jq '. | length') -eq 0 ]]; then
        echo '{"error": "Note not found"}'
        exit 1
    fi

    local note_id
    note_id=$(echo "$note" | jq -r '.[0].ZUNIQUEIDENTIFIER')

    local tags
    tags=$(sqlite3 -json "$DB" "
        SELECT t.ZTITLE
        FROM ZSFNOTETAG t
        JOIN Z_5TAGS nt ON t.Z_PK = nt.Z_13TAGS
        JOIN ZSFNOTE n ON nt.Z_5NOTES = n.Z_PK
        WHERE n.ZUNIQUEIDENTIFIER = '${note_id}'
    " | jq -c '[.[].ZTITLE]')

    echo "$note" | jq -c --argjson tags "$tags" '.[0] | {
        id: .ZUNIQUEIDENTIFIER,
        title: (.ZTITLE // "Untitled"),
        content: .ZTEXT,
        created: .ZCREATIONDATE,
        modified: .ZMODIFICATIONDATE,
        tags: $tags
    }'
}

cmd_create() {
    local text="$1"
    local title="${2:-}"
    local tags="${3:-}"

    local params=("text" "$text")
    [[ -n "$title" ]] && params+=("title" "$title")
    [[ -n "$tags" ]] && params+=("tags" "$tags")

    local url
    url=$(build_url "create" "${params[@]}")
    execute_bear_url "$url"
    echo '{"success": true, "message": "Note created"}'
}

cmd_add_text() {
    local id="$1"
    local text="$2"
    local mode="${3:-append}"

    local params=("id" "$id" "text" "$text" "mode" "$mode")

    local url
    url=$(build_url "add-text" "${params[@]}")
    execute_bear_url "$url"
    echo '{"success": true, "message": "Text added to note"}'
}

cmd_tags() {
    check_db

    sqlite3 -json "$DB" "
        SELECT t.ZTITLE, COUNT(nt.Z_5NOTES) as note_count
        FROM ZSFNOTETAG t
        LEFT JOIN Z_5TAGS nt ON t.Z_PK = nt.Z_13TAGS
        LEFT JOIN ZSFNOTE n ON nt.Z_5NOTES = n.Z_PK AND n.ZTRASHED = 0
        GROUP BY t.ZTITLE
        ORDER BY t.ZTITLE
    " | jq -c '.[] | {name: .ZTITLE, note_count: .note_count}'
}

cmd_tag() {
    local name="$1"

    check_db

    sqlite3 -json "$DB" "
        SELECT DISTINCT n.ZUNIQUEIDENTIFIER, n.ZTITLE, n.ZTEXT, n.ZCREATIONDATE, n.ZMODIFICATIONDATE
        FROM ZSFNOTE n
        JOIN Z_5TAGS nt ON n.Z_PK = nt.Z_5NOTES
        JOIN ZSFNOTETAG t ON nt.Z_13TAGS = t.Z_PK
        WHERE t.ZTITLE LIKE '%${name}%' AND n.ZTRASHED = 0
        ORDER BY n.ZMODIFICATIONDATE DESC
    " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
}

cmd_untagged() {
    local search="${1:-}"

    check_db

    if [[ -n "$search" ]]; then
        sqlite3 -json "$DB" "
            SELECT n.ZUNIQUEIDENTIFIER, n.ZTITLE, n.ZTEXT, n.ZCREATIONDATE, n.ZMODIFICATIONDATE
            FROM ZSFNOTE n
            WHERE n.Z_PK NOT IN (SELECT DISTINCT Z_5NOTES FROM Z_5TAGS)
              AND n.ZTRASHED = 0
              AND (n.ZTITLE LIKE '%${search}%' OR n.ZTEXT LIKE '%${search}%')
            ORDER BY n.ZMODIFICATIONDATE DESC
        " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
    else
        sqlite3 -json "$DB" "
            SELECT n.ZUNIQUEIDENTIFIER, n.ZTITLE, n.ZTEXT, n.ZCREATIONDATE, n.ZMODIFICATIONDATE
            FROM ZSFNOTE n
            WHERE n.Z_PK NOT IN (SELECT DISTINCT Z_5NOTES FROM Z_5TAGS)
              AND n.ZTRASHED = 0
            ORDER BY n.ZMODIFICATIONDATE DESC
            LIMIT 20
        " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
    fi
}

cmd_todos() {
    local search="${1:-}"

    check_db

    local pattern="- [ ]"
    if [[ -n "$search" ]]; then
        pattern="${pattern}%${search}"
    fi

    sqlite3 -json "$DB" "
        SELECT ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT, ZCREATIONDATE, ZMODIFICATIONDATE
        FROM ZSFNOTE
        WHERE ZTEXT LIKE '%${pattern}%' AND ZTRASHED = 0
        ORDER BY ZMODIFICATIONDATE DESC
        LIMIT 20
    " | jq -c '.[] | {
        id: .ZUNIQUEIDENTIFIER,
        title: (.ZTITLE // "Untitled"),
        content_preview: (.ZTEXT[:200] + "..."),
        created: .ZCREATIONDATE,
        modified: .ZMODIFICATIONDATE,
        todo_items: [(.ZTEXT | split("\n")[] | select(contains("- [ ]")))][:5]
    }'
}

cmd_today() {
    local search="${1:-}"

    check_db

    # Get today's timestamp in Core Data format
    local today
    today=$(date -j -f "%Y-%m-%d %H:%M:%S" "$(date +%Y-%m-%d) 00:00:00" "+%s")
    local core_data_epoch=978307200
    local today_ts=$((today - core_data_epoch))

    if [[ -n "$search" ]]; then
        sqlite3 -json "$DB" "
            SELECT ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT, ZCREATIONDATE, ZMODIFICATIONDATE
            FROM ZSFNOTE
            WHERE ZCREATIONDATE >= ${today_ts}
              AND (ZTITLE LIKE '%${search}%' OR ZTEXT LIKE '%${search}%')
              AND ZTRASHED = 0
            ORDER BY ZMODIFICATIONDATE DESC
        " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
    else
        sqlite3 -json "$DB" "
            SELECT ZUNIQUEIDENTIFIER, ZTITLE, ZTEXT, ZCREATIONDATE, ZMODIFICATIONDATE
            FROM ZSFNOTE
            WHERE ZCREATIONDATE >= ${today_ts} AND ZTRASHED = 0
            ORDER BY ZMODIFICATIONDATE DESC
        " | jq -c '.[] | {id: .ZUNIQUEIDENTIFIER, title: (.ZTITLE // "Untitled"), content_preview: (.ZTEXT[:200] + "..."), created: .ZCREATIONDATE, modified: .ZMODIFICATIONDATE}'
    fi
}

cmd_grab_url() {
    local url="$1"
    local tags="${2:-}"

    local params=("url" "$url")
    [[ -n "$tags" ]] && params+=("tags" "$tags")

    local bear_url
    bear_url=$(build_url "grab-url" "${params[@]}")
    execute_bear_url "$bear_url"
    echo '{"success": true, "message": "URL grabbed"}'
}

cmd_rename_tag() {
    local name="$1"
    local new_name="$2"

    local url
    url=$(build_url "rename-tag" "name" "$name" "new_name" "$new_name")
    execute_bear_url "$url"
    echo '{"success": true, "message": "Tag renamed"}'
}

cmd_delete_tag() {
    local name="$1"

    local url
    url=$(build_url "delete-tag" "name" "$name")
    execute_bear_url "$url"
    echo '{"success": true, "message": "Tag deleted"}'
}

cmd_trash() {
    local id="$1"

    local url
    url=$(build_url "trash" "id" "$id")
    execute_bear_url "$url"
    echo '{"success": true, "message": "Note moved to trash"}'
}

# Usage information
usage() {
    cat <<EOF
Usage: bear <command> [arguments]

Commands:
  search <term> [tag]           Search notes by term, optionally filter by tag
  open <id>                     Get note content by ID
  open-title <title>            Get note by title
  create <text> [title] [tags]  Create new note
  add-text <id> <text> [mode]   Add text to note (mode: append/prepend/replace_all)
  tags                          List all tags with note counts
  tag <name>                    List notes with specific tag
  untagged [search]             List untagged notes
  todos [search]                List notes containing unchecked todos
  today [search]                List notes created today
  grab-url <url> [tags]         Create note from URL
  rename-tag <name> <new_name>  Rename tag
  delete-tag <name>             Delete tag
  trash <id>                    Move note to trash

Examples:
  bear search "meeting notes"
  bear search "project" "work"
  bear open "ABC123-456DEF-789"
  bear create "My note content" "Note Title" "tag1,tag2"
  bear tags
  bear tag "work"
  bear todos
  bear today

All output is in JSON format (one object per line for lists).
EOF
    exit 1
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        usage
    fi

    local command="$1"
    shift

    case "$command" in
        search)
            [[ $# -lt 1 ]] && usage
            cmd_search "$@"
            ;;
        open)
            [[ $# -ne 1 ]] && usage
            cmd_open "$1"
            ;;
        open-title)
            [[ $# -ne 1 ]] && usage
            cmd_open_title "$1"
            ;;
        create)
            [[ $# -lt 1 ]] && usage
            cmd_create "$@"
            ;;
        add-text)
            [[ $# -lt 2 ]] && usage
            cmd_add_text "$@"
            ;;
        tags)
            cmd_tags
            ;;
        tag)
            [[ $# -ne 1 ]] && usage
            cmd_tag "$1"
            ;;
        untagged)
            cmd_untagged "$@"
            ;;
        todos)
            cmd_todos "$@"
            ;;
        today)
            cmd_today "$@"
            ;;
        grab-url)
            [[ $# -lt 1 ]] && usage
            cmd_grab_url "$@"
            ;;
        rename-tag)
            [[ $# -ne 2 ]] && usage
            cmd_rename_tag "$@"
            ;;
        delete-tag)
            [[ $# -ne 1 ]] && usage
            cmd_delete_tag "$1"
            ;;
        trash)
            [[ $# -ne 1 ]] && usage
            cmd_trash "$1"
            ;;
        *)
            echo "Unknown command: $command" >&2
            usage
            ;;
    esac
}

main "$@"
